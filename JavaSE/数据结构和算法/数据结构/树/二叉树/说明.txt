前序查找思路:
1.先判断当前节点的no值是否等于要查找的
2.如果是相等的,那就返回当前节点
3.如果不相等,那就判断当前节点的左儿子是否为空,如果不为空则递归前序查找
4.如果左递归前序查找,找到了节点则返回,否则继续判断当前节点的右儿子是否为空,如果不为空则继续向右递归前序查找









中序查找思路:
1.判断当前节点的左儿子是否为空,如果不为空则递归中序查找
2.如果找到则返回,如果没有找到就和当前节点比较,如果是则返回当前节点,否则继续前进右递归的中序查找
3.如果右递归中序查找,找到了就返回,否则返回null








后序查找思路:
1.判断当前节点的左儿子是否为空,如果不为空,则递归后序查找
2.如果找到了就返回,如果没有找到就判断当前节点的右儿子是否为空,如果不为空则右递归进行后序查找,如果找到就返回
3.如果右递归没有找到,和当前节点进行比较,如果是则返回,否则返回null






需求:
1.如果要删除的是叶子节点,那就删除该节点
2.如果要删除的是根,则删除该子树
删除:
0.如果树是空树,如果只有一个根节点,则等价将二叉树置空

1.因为二叉树是单链的,所以要判断当前节点的子节点是否要删除,而不是去判断当前这个节点是不是要删除
2.如果当前节点的左子节点不为空,并且左子节点就是要删除的,就将this.left=null;并且return;
3.如果当前节点的右子节点不为空,并且右子节点就是要删除的节点,就将this.right=null;并且return
4.如果第2步和第3步没有删除节点,那么就要向左子树进行递归删除
5.如果第4步也没有删除节点,那么向右子树进行递归删除


